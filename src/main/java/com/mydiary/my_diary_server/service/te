package com.mydiary.my_diary_server.service;

import com.mydiary.my_diary_server.domain.ChatRoom;
import com.mydiary.my_diary_server.domain.Message;
import com.mydiary.my_diary_server.domain.User;
import com.mydiary.my_diary_server.dto.AddMessageRequest;
import com.mydiary.my_diary_server.dto.MessageResponse;
import com.mydiary.my_diary_server.repository.MessageRepository;
import com.mydiary.my_diary_server.repository.UserRepository;
import jakarta.transaction.Transactional;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.*;

@Service
@Slf4j
public class MessageService {

    private final MessageRepository messageRepository;
    private final UserRepository userRepository;

    MessageService(MessageRepository messageRepository, UserRepository userRepository){
        this.messageRepository = messageRepository;
        this.userRepository = userRepository;
    }

    // 메시지 생성
    public MessageResponse save(AddMessageRequest request, Long senderId) {
        Optional<User> sender = userRepository.findById(senderId);
        Optional<User> receiver = userRepository.findById(request.getReceiverId());

        return new MessageResponse(messageRepository.save(Message.builder()
                .senderId(sender.get().getId())
                .receiverId(receiver.get().getId())
                .content(request.getContent())
                .sentAt(request.getSentAt())
                .isRead(false) // 쪽지 초기값은 안읽은 모두 
                .build()));
    }

    // 메시지 조회 by ID
    public Message getMessageById(Long id) {
        Optional<Message> messageOptional = messageRepository.findById(id);
        return messageOptional.orElse(null);
    }

    // 메시지 업데이트 by ID
    public Message updateMessage(Long id, Message updatedMessage) {
        Optional<Message> messageOptional = messageRepository.findById(id);
        if (messageOptional.isPresent()) {
            Message message = messageOptional.get();
            message.setContent(updatedMessage.getContent());
            message.setSentAt(updatedMessage.getSentAt());
            // 추가 필드 업데이트

            return messageRepository.save(message);
        }
        return null;
    }

    // 메시지 삭제 by ID
    public void deleteMessage(Long id) {
        messageRepository.deleteById(id);
    }

    @Transactional
    public List<Message> findChats(Long otherUserId, Long userId) {
        List<Message> messages = messageRepository.findByReceiverIdAndSenderIdOrReceiverIdAndSenderId(userId, otherUserId, otherUserId, userId)
                .orElseThrow(() -> new IllegalArgumentException("not found find chats / id : " + userId + "otherUserId: " + otherUserId));
        for (Message message : messages) {
            if(message.getReceiverId() == userId){
                message.setRead(true);
            }
        }
        
        return messages;
    }


    public List<ChatRoom> getAllChatRooms(Long userId) {
        // 사용자의 id와 관련된 메시지를 찾아 채팅방으로 반환
        List<Message> userMessages = messageRepository.findByReceiverIdOrSenderId(userId, userId);

        // 각 채팅방별로 마지막 메시지와 대화 상대를 가져옴
        Map<Long, ChatRoom> chatRoomsMap = new HashMap<>();
        for (Message message : userMessages) {
            Long otherUserId = (message.getReceiverId().equals(userId)) ? message.getSenderId() : message.getReceiverId();

            ChatRoom chatRoom = chatRoomsMap.get(otherUserId);
            if (chatRoom == null) {
                chatRoom = new ChatRoom(otherUserId, "Room with User " + otherUserId, message.isRead());
            }

            if(!userRepository.findById(otherUserId).isPresent())
                continue;

            // 마지막 메시지 업데이트
            chatRoom.setLastMessage(message.getContent());
            chatRoom.setLastMessageSentAt(message.getSentAt());
            chatRoom.setName(userRepository.findById(otherUserId).get().getUsername());

            if(message.getReceiverId()==userId && !message.isRead()){
                chatRoom.setRead(false);
            }else{
                chatRoom.setRead(true);
            }

            chatRoomsMap.put(otherUserId, chatRoom);
        }

        // Map의 값들을 List로 반환
        return new ArrayList<>(chatRoomsMap.values());
    }

    public void deleteAllMessagesByUserId(Long userId) {
        // 사용자의 id와 관련된 메시지를 찾아 삭제
        List<Message> userMessages = messageRepository.findByReceiverIdOrSenderId(userId, userId);

        messageRepository.deleteAll(userMessages);
    }
}
package com.mydiary.my_diary_server.service;

import java.io.*;
import java.net.*;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;

import com.google.gson.Gson;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

@Service
public class AudioRecongnitionService {


    public String PostTranscribeSample(MultipartFile audioFile) throws IOException, InterruptedException {
        String accessToken = GetAccessToken();

        // MultipartFile을 File로 변환
        File convertedFile = convertMultipartFileToFile(audioFile);

        // API 엔드포인트 및 HTTP 연결 설정
        URL url = new URL("https://openapi.vito.ai/v1/transcribe");
        HttpURLConnection httpConn = (HttpURLConnection) url.openConnection();
        httpConn.setRequestMethod("POST");
        httpConn.setRequestProperty("accept", "application/json");
        httpConn.setRequestProperty("Authorization", "Bearer " + accessToken);
        httpConn.setRequestProperty("Content-Type", "multipart/form-data;boundary=authsample");
        httpConn.setDoOutput(true);

        try (DataOutputStream outputStream = new DataOutputStream(httpConn.getOutputStream())) {
            // 파일 전송 부분 시작
            outputStream.writeBytes("--authsample\r\n");
            outputStream.writeBytes("Content-Disposition: form-data; name=\"file\";filename=\"" + convertedFile.getName() + "\"\r\n");
            outputStream.writeBytes("Content-Type: " + URLConnection.guessContentTypeFromName(convertedFile.getName()) + "\r\n");
            outputStream.writeBytes("Content-Transfer-Encoding: binary" + "\r\n");
            outputStream.writeBytes("\r\n");

            // 파일 내용 전송
            try (FileInputStream in = new FileInputStream(convertedFile)) {
                byte[] buffer = new byte[4096];
                int bytesRead;
                while ((bytesRead = in.read(buffer)) != -1) {
                    outputStream.write(buffer, 0, bytesRead);
                }
            }

            // 나머지 폼 데이터 전송
            outputStream.writeBytes("\r\n");
            outputStream.writeBytes("--authsample\r\n");
            outputStream.writeBytes("Content-Disposition: form-data; name=\"config\"\r\n");
            outputStream.writeBytes("Content-Type: application/json\r\n");
            outputStream.writeBytes("\r\n");
            outputStream.writeBytes("{}");
            outputStream.writeBytes("\r\n");
            outputStream.writeBytes("--authsample\r\n");
        }

        InputStream responseStream = httpConn.getResponseCode() / 100 == 2
                ? httpConn.getInputStream()
                : httpConn.getErrorStream();
        Scanner s = new Scanner(responseStream).useDelimiter("\\A");
        String response = s.hasNext() ? s.next() : "";
        s.close();
        System.out.println("파일 분석 바디" + response);

        Gson gson = new Gson();
        IdResponse idResponse = gson.fromJson(response, IdResponse.class);

        // 응답에서 id 값을 가져옴
        String id = idResponse.getId();

        System.out.println("ID: " + id);
        Thread.sleep((int) (convertedFile.length() / 1024) * 50L); // 5초 동안 코드를 지연

        return GetTranscribeSample(id,accessToken);

    }

    public File convertMultipartFileToFile(MultipartFile multipartFile) throws IOException {
        // MultipartFile을 File로 변환하는 부분
        File file = File.createTempFile("temp", null);
        multipartFile.transferTo(file);
        return file;
    }

    public String GetAccessToken() throws IOException {
        String CLIENT_ID = "XoWxCBzaDz0tsQ7WyXHH";
        String CLIENT_SECRET = "i0VCNYdITLcERiAqZbzmjICf1yCqrvWyamFbzZYS";

        URL url = new URL("https://openapi.vito.ai/v1/authenticate");
        HttpURLConnection httpConn = (HttpURLConnection) url.openConnection();
        httpConn.setRequestMethod("POST");
        httpConn.setRequestProperty("accept", "application/json");
        httpConn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
        httpConn.setDoOutput(true);

        String data = "client_id="+ CLIENT_ID +"&client_secret=" + CLIENT_SECRET;

        byte[] out = data.getBytes(StandardCharsets.UTF_8);

        OutputStream stream = httpConn.getOutputStream();
        stream.write(out);

        InputStream responseStream = httpConn.getResponseCode() / 100 == 2
                ? httpConn.getInputStream()
                : httpConn.getErrorStream();
        Scanner s = new Scanner(responseStream).useDelimiter("\\A");
        String response = s.hasNext() ? s.next() : "";
        s.close();
        System.out.println(response);

        Gson gson = new Gson();
        AccessTokenResponse accessTokenResponse = gson.fromJson(response, AccessTokenResponse.class);

        // 응답에서 access_token 값을 가져옴
        String accessToken = accessTokenResponse.getAccessToken();

        System.out.println("Access Token: " + accessToken);

        return accessToken;
    }

    public String GetTranscribeSample(String id, String accessToken) throws IOException {
        URL url = new URL("https://openapi.vito.ai/v1/transcribe/"+id);
        HttpURLConnection httpConn = (HttpURLConnection) url.openConnection();
        httpConn.setRequestMethod("GET");
        httpConn.setRequestProperty("accept", "application/json");
        httpConn.setRequestProperty("Authorization", "Bearer " + accessToken);

        InputStream responseStream = httpConn.getResponseCode() / 100 == 2
                ? httpConn.getInputStream()
                : httpConn.getErrorStream();
        Scanner s = new Scanner(responseStream).useDelimiter("\\A");
        String response = s.hasNext() ? s.next() : "";
        s.close();
        System.out.println(response);

        // JSON 파싱
        Gson gson = new Gson();
        ApiResponse apiResponse = gson.fromJson(response, ApiResponse.class);

        if(apiResponse.getStatus().equals("transcribing")){
            try {
                Thread.sleep(500); // 0.5초 동안 코드를 지연

                // 재귀적으로 GetTranscribeSample 호출
                return GetTranscribeSample(id, accessToken);
            } catch (InterruptedException e) {
                // InterruptedException 처리
                System.out.println("Error during sleep: " + e.getMessage());
            }
        }


        try {
            Utterance[] utterances = apiResponse.getResults().getUtterances();

            // utterances 배열이 비어 있지 않고 첫 번째 요소가 존재하는 경우에만 처리
            if (utterances != null && utterances.length > 0) {
                String msg = utterances[0].getMsg();

                // msg가 비어 있지 않은 경우에만 출력
                if (msg != null && !msg.isEmpty()) {
                    System.out.println("msg: " + msg);
                    return msg;
                } else {
                    System.out.println("msg is empty or null.");
                    return "";
                }
            } else {
                System.out.println("No utterances found in the response.");
                return "";
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            // ArrayIndexOutOfBoundsException 발생 시에 대한 처리
            System.out.println("Error accessing utterances array: " + e.getMessage());
        } catch (Exception e) {
            // 다른 예외가 발생한 경우에 대한 처리
            System.out.println("Error processing API response: " + e.getMessage());
        }


        return "";
    }
}

// ApiResponse 클래스 정의
class ApiResponse {
    private String id;
    private String status;
    private Results results;

    // Getter 메서드 (생략)

    public String getId() {
        return id;
    }

    public String getStatus() {
        return status;
    }

    public Results getResults() {
        return results;
    }
}

// Results 클래스 정의
class Results {
    private Utterance[] utterances;
    private boolean verified;

    // Getter 메서드 (생략)

    public Utterance[] getUtterances() {
        return utterances;
    }

    public boolean isVerified() {
        return verified;
    }
}

// Utterance 클래스 정의
class Utterance {
    private int start_at;
    private int duration;
    private int spk;
    private String spk_type;
    private String msg;

    // Getter 메서드 (생략)

    public int getStart_at() {
        return start_at;
    }

    public int getDuration() {
        return duration;
    }

    public int getSpk() {
        return spk;
    }

    public String getSpk_type() {
        return spk_type;
    }

    public String getMsg() {
        return msg;
    }
}
class IdResponse {
    private String id;

    public String getId() {
        return id;
    }
}


class AccessTokenResponse {
    private String access_token;
    private long expire_at;

    public String getAccessToken() {
        return access_token;
    }

    public long getExpireAt() {
        return expire_at;
    }
}
